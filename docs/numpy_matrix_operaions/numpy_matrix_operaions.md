# Numpy与矩阵运算

## 引例

在工程实践中，我们常常需要运用计算机来辅助矩阵运算（毕竟对于大型的矩阵不可能像学习线性代数时一样用纸和笔算）。Python中的numpy库就提供了很多面向矩阵运算的数学函数。下面我们一起来看一个利用numpy进行矩阵运算例子。

两向量间有外积运算：
$$
  b\otimes a \rightarrow
  \begin{pmatrix}
    b_1\\ b_2\\ b_3\\ b_4
  \end{pmatrix}
  \begin{pmatrix}
    a_1 & a_2 & a_3
  \end{pmatrix} = 
  \begin{pmatrix}
    a_1b_1 & a_2b_1 & a_3b_1\\
    a_1b_2 & a_2b_2 & a_3b_2\\
    a_1b_3 & a_2b_3 & a_3b_3\\
    a_1b_4 & a_2b_4 & a_3b_4
  \end{pmatrix}
$$

两向量外积的结果是一个矩阵。可以证明，该矩阵的秩为1。我们可以用numpy随机生成两个向量来验证这个结论。

```python
  import numpy as np # 导入numpy库

  ## 生成两个向量
  x1 = np.arange(300, 600, 10)
  x2 = np.arange(300, 650, 10)

  ## 运用上述向量生成高斯峰
  y1 = 0.8 * np.exp(-((x1 - 380) / 40) ** 2)
  y2 = 0.8 * np.exp(-((x2 - 480) / 40) ** 2)

  y1 = y1 + np.random.random(len(x1)) / 20 # 对其中一个向量进行随机调整
  data = np.outer(y1, y2) # 求两向量的外积
  u, s, vh = np.linalg.svd(data) # 奇异值分解
  print(s) # 打印奇异值
```

最终输出的结果为：
```
[3.47754896e+00 3.47476944e-16 3.47476944e-16 3.47476944e-16
 3.47476944e-16 3.47476944e-16 3.47476944e-16 3.47476944e-16
 3.47476944e-16 3.47476944e-16 3.47476944e-16 3.47476944e-16
 3.47476944e-16 3.47476944e-16 3.47476944e-16 3.47476944e-16
 3.47476944e-16 3.47476944e-16 3.47476944e-16 3.47476944e-16
 3.47476944e-16 3.47476944e-16 3.47476944e-16 3.47476944e-16
 3.47476944e-16 3.47476944e-16 3.47476944e-16 3.47476944e-16
 3.47476944e-16 3.47476944e-16]
```

可以看到，除第一个奇异值外，其他的奇异值很小很小，验证了我们的猜想。在验证的过程中，调用了这几个函数，我们对其进行简短的介绍：
  - `arange` 用于生成在一定范围内、有一定步长的一串数；
  - `exp` 用于对数或数组里的每一个元素进行指数运算，不同于`math.exp`只能对数进行运算；
  - `random` 用于生成随机数或数组；
  - `outer` 用于求两向量的外积；
  - `svd` 用于进行奇异值分解。

在具体使用时，这些函数的参数无需记忆，可以随时通过`help`查看帮助文档。

## 文件操作

我们用来计算的数据往往是从文件中加载的，运算的结果也需要保存到文件中，以备后续使用。对于文件操作，numpy提供了这方面的函数。

我们在同一目录下有一个文件`input.txt`，它包括下列数据：
```
  0.626	0.425	0.368	0.706	0.510	0.183
  0.708	0.476	0.408	0.800	0.574	0.202
  0.765	0.513	0.437	0.872	0.628	0.218
  0.808	0.541	0.462	0.928	0.671	0.243
  0.825	0.566	0.495	0.942	0.694	0.296
```

若想要读取该文件中的数据作为二维数组，则可以使用下列代码：
```python
  x = np.loadtxt("input.txt", delimiter='\t')
```
其中`input.txt`是文件名，参数`delimiter`指定了被读取的文件里不同列间的分隔符。如果文件中的每行数据形如：
```
  0.626,0.425,0.368,0.706,0.510,0.183
```
则需要让`delimiter=','`。

若想要将数组中的值保存成文件，则可以使用下列代码：
```python
  np.savetxt("output.txt", x, fmt="%3.2f", delimiter=',', newline='\n')
```
其中`output.txt`是文件名，参数`delimiter`与读取文件时的`delimiter`意义相同，`fmt`指定了输出数据的格式，`newline`指定了换行符。

## 矩阵操作

### 特殊矩阵

在应用中，可能会用到一些特殊矩阵，例如零矩阵、单位阵等。

#### 零矩阵

如`np.zeros((2, 3))`。其中，参数`(2, 3)`指定了数组的形状，因此得到数组：
```
  [[0., 0., 0.],
   [0., 0., 0.]]
```
类似地，也可以通过`np.ones`函数生成所有元素都是一的数组。

#### 单位矩阵


如`np.eye(3)`。其中，参数`3`指定了方阵的阶数，因此得到数组：
```
  [[1., 0., 0.],
   [0., 1., 0.],
   [0., 0., 1.]]
```

函数`np.eye`不仅可以生成单位方阵，还可以生成包含单位方阵的任意形状的矩阵。例如`np.eye(3, 4)`会得到数组：
```
  [[1., 0., 0., 0.],
   [0., 1., 0., 0.],
   [0., 0., 1., 0.]]
```
其中参数`(3, 4)`指定了数组的形状。这样，矩阵的前三列和矩阵的三行组成子矩阵是一个单位方阵。如果想要后三列呢？可以调用`np.eye(3, 4, 1)`，会得到数组：
```
  [[0., 1., 0., 0.],
   [0., 0., 1., 0.],
   [0., 0., 0., 1.]]
```
其中，第三个参数指定了对角线的开始位置的列序号。

#### 随机数矩阵

在引例中，我们介绍了`np.random.random`函数，它能够根据参数中指定的形状，生成包含$[0, 1)$范围内数的数组。例如：
```python
  >>> np.random.random(5)
  >>> array([0.14141456, 0.51540024, 0.72299594, 0.38008252, 0.16445977])
  >>> np.random.random((1, 5))
  >>> array([[0.99043471, 0.71934765, 0.21817372, 0.57344439, 0.61945634]])
```
上述两个数组尽管都只有一行，但是有一定区别。上面的数组是一维的，下面的则是二维的。可以通过`shape`方法查看：
```python
  x1 = np.random.random(5)
  x2 = np.random.random((1, 5))
  print(x1.shape)
  print(x2.shape)
```
得到结果：
```
  (5,)
  (1, 5)
```

如果`random`函数的参数为空，则返回一个随机数：
```python
  >>> np.random.random()
  >>> 0.26022440891004406
```

当然，numpy也提供了生成其他很多分布的随机数的函数，例如正态分布`standard_normal()`、泊松分布`poisson()`等。

有时，我们也需要从一个指定序列中随机抽取几个数。使用函数`np.random.choice()`即可实现。例如：
```python
  x = np.arange(0, 10)
  p = [0.11, 0.09, 0.13, 0.07, 0.15, 0.05, 0.17, 0.03, 0.19, 0.01]
  np.random.choice(x, 5, replace=True, p=p)
```
输出结果为`array([2, 4, 4, 4, 2])`。其中参数`p`指定了抽到对应位置上元素的概率，默认均匀抽取；参数`replace`指定了是否重复抽取，默认可以重复抽取。

#### 自定义矩阵
除了从文件中读取矩阵，有时当然也需要临时定义矩阵，只需要用`array`函数即可。例如：
```python
  >>> np.array([1, 2, 3]) # 定义一维数组
  >>> np.array([[1, 2, 3], [4, 5, 6]]) # 定义二维数组
```
也可以通过`reshape`函数改变数组的形状。`reshape`函数的使用在下文有一些例子可以参考。

### 合并、分片与过滤

#### 矩阵合并
矩阵合并分为按列合并和按行合并。例如，对于线性方程组的系数矩阵和常数项，通过按列合并得到增广矩阵：
```python
  >>> C = np.array([[1, 2, 3], [4, 5, 6]])
  >>> b = np.ones((2, 1))
  >>> np.c_[C, b] # 按列合并
  >>> array([[1., 2., 3., 1.],
             [4., 5., 6., 1.]])
```
对于优化问题而言，有时我们需要在已有约束的基础上继续添加约束：
```python
  >>> C = np.array([[1, 2, 3], [4, 5, 6]])
  >>> z = np.array([[7, 8, 9]])
  >>> np.r_[C, z] # 按行合并
  >>> array([[1, 2, 3],
             [4, 5, 6],
             [7, 8, 9]])
```
需要注意的是，合并的数组可以是一维，甚至也可以是零维的数，此时会自动升维。例如：
```python
  >>> np.c_[np.array([1, 2, 3]), np.array([4, 5, 6])]
  >>> array([[1, 4],
             [2, 5],
             [3, 6]])
```
此时，数组`array([1, 2, 3])`会升维成`(3, 1)`的二维数组。再例如：
```python
  >>> np.c_[np.array([[1, 2, 3]]), 0, 0, np.array([[4, 5, 6]])]
  >>> array([[1, 2, 3, 0, 0, 4, 5, 6]])
```
此时，数字会升维成`(1, 1)`的二维数组。

#### 矩阵切片
在进行机器学习时，常常需要将数据集划为两部分，选取其中一部分进行训练，体现在矩阵上即选取矩阵中的一部分元素，也就是矩阵切片。例如：
```python
  >>> A = np.random.standard_normal((5, 5))
  >>> print(A)
  >>> [[-0.53928989  0.270161    1.54383567 -0.87217571  0.11524027]
       [ 0.1754583  -0.2690871   0.26210902  0.14245563 -0.37025879]
       [ 0.24753496  1.77830985  0.19337618  0.36931134 -1.06104625]
       [-0.57307738  2.09989967  2.14540914  2.24098208  1.54430995]
       [ 0.11108045 -0.35704354 -0.10025212  0.19846681 -0.25776957]]
  >>> A[1, :] # 注意此时的数组维度
  >>> array([ 0.1754583 , -0.2690871 ,  0.26210902,  0.14245563, -0.37025879])
  >>> A[2:4, 1:3]
  >>> array([[1.77830985, 0.19337618],
             [2.09989967, 2.14540914]])
  >>> A[:2, -2:-1]
  >>> array([[-0.87217571],
             [ 0.14245563]])
```
这与列表中的切片操作大致相同。有一点值得注意，若某一维度只有一个数字，则会对数组进行降维，例如：
```python
  >>> np.arange(0, 32).reshape((4, 2, 4))[1, :, :].shape
  >>> (2, 4)
  >>> np.arange(0, 32).reshape((4, 2, 4))[1:2, :, :].shape
  >>> (1, 2, 4)
```
也可以按照指定的索引进行切片，例如：
```python
  >>> A = np.arange(0, 25).reshape((5, 5))
  >>> A[[0, 3, 2], :]
  >>> array([[ 0,  1,  2,  3,  4],
             [15, 16, 17, 18, 19],
             [10, 11, 12, 13, 14]])
  >>> A[[1], :]
  >>> array([[5, 6, 7, 8, 9]]) # 注意此时的数组维度
```
在这种需求下，尽量不要在多个维度同时切片，否则会出现意外甚至报错。例如对上述的`A`数组：
```python
  >>> A[[1], [1, 2]] # 相当于A[1, [1, 2]]
  >>> array([6, 7])
  >>> A[[1, 2, 3], [1, 2, 3]] # 切取了(1, 1)(2, 2)(3, 3)处的三个元素
  >>> A[[1, 2, 3], [1, 2]] # 报错
  >>> IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (3,) (2,) 
```
如果想要筛选出数组中满足条件的元素，例如数组中5的整数，可以进行如下操作：
```python
  >>> A[A%5 == 0]
  >>> array([ 0,  5, 10, 15, 20])
```

#### 矩阵函数
常见的矩阵函数有求和函数`sum`、标准差函数`std`、均值函数`mean`。默认情况下，这些函数会对矩阵中的所有元素进行计算：
```python
  >>> A = np.random.standard_normal(100)
  >>> print(A.sum(), A.mean(), A.std())
  >>> -8.195680256870403 -0.08195680256870404 0.9252919601624465
```
也可以按行或列进行计算，指定参数`axis`即可。例如：
```python
  >>> np.sum([[0, 1], [0, 5]], axis=0, keepdims=True) # 每一列求和
  >>> array([[0, 6]])
  >>> np.sum([[0, 1], [0, 5]], axis=1, keepdims=True) # 每一行求和
  >>> array([[1],
             [5]])
```
其中，参数`keepdims`指定了数组的维数不会发生改变，默认值是`False`。例如：
```python
  >>> np.sum([[0, 1], [0, 5]], axis=1) # 每一行求和
  >>> array([1, 5])
```
数组就从二维变成了一维。

## 矩阵运算

这一节涉及众多线性代数里的运算，包括加法、减法、转置、矩阵乘法等。

#### 加减运算
```python
  >>> A = np.arange(0, 6).reshape(2, 3)
  >>> B = np.arange(0, 6).reshape(2, 3)
  >>> A + B
  >>> array([[ 0,  2,  4],
             [ 6,  8, 10]])
```

#### 矩阵转置
```python
  >>> A.T
  >>> array([[0, 3],
             [1, 4],
             [2, 5]])
```

#### 矩阵乘法
矩阵乘法即是线性代数中的$A_{m\times n} B_{n\times l}$，需要保证前一个矩阵的列数等于后一个矩阵的行数。
```python
  >>> A @ A.T
  >>> array([[ 5, 14],
             [14, 50]]
```

需要与‘`@`’运算符区分的是‘`*`’运算符。‘`*`’是将两矩阵对应元素进行相乘的运算符，即：
```python
  >>> A * B
  >>> array([[ 0,  1,  4],
             [ 9, 16, 25]])
  >>> A * B[0][:]
  >>> array([[ 0,  1,  4],
             [ 0,  4, 10]])
```
同样的，‘`/`’也可以作为两矩阵对应元素相除的运算符。

#### 矩阵乘方
```python
  >>> A ** 2
  >>> array([[ 0,  1,  4],
             [ 9, 16, 25]])
```

#### 矩阵求逆
```python
  A = np.random.standard_normal((3, 3))
  A_inv = np.linalg.inv(A) # 矩阵求逆
  A @ A_inv
```

#### 广播规则
在简单的情况下，‘`+`’‘`-`’‘`*`’‘`/`’运算符左右的数组都具有相同的形状，但是numpy 的广播规则允许两个数组形状不同。在对两个数组进行操作时，numpy将按`shape`返回的元组从右向左的顺序依次比较各个维度上的元素个数。当每个维度上的元素个数满足下列条件之一时：
  - 相等；
  - 其中之一为1；
两数组可以兼容。例如：
```python
  A = np.arange(0, 48).reshape(8, 1, 6, 1)
  print(A.shape)
  B = np.arange(0, 35).reshape(7, 1, 5)
  print(B.shape)
  print((A + B).shape)
```
得到输出为：
```python
  (8, 1, 6, 1)
  (7, 1, 5)
  (8, 7, 6, 5)  
```

## 数据处理实战——线性回归

现有一数据集（命名为`data.csv`文件），数据来源于某班级学生填写的调查问卷。数据集中每一行有4个数，依次代表性别（0表示女，1表示男）、平均绩点、期望毕业时月薪（单位：千元）、期望毕业五年后月薪（单位：千元）。

通过统计学方法可以得到如下结论：对于女生，期望毕业五年后月薪和期望毕业时月薪间有显著的线性关系；对于男生，期望毕业五年后月薪和平均绩点间有显著的线性关系。现需要你分别计算出预测不同性别学生期望毕业五年后月薪的表达式。

对于这个问题，需要求解的是线性回归系数，使用的较多的方法是最小二乘法。记数据集中有$m$个观测值，$m$个$n$维自变量$\boldsymbol{x}$组成的矩阵为$\boldsymbol{X}_{m\times n}$，$m$个因变量$y$组成的向量为$\boldsymbol{y}$，假设有$y = \boldsymbol{ax} + \epsilon$，其中$\epsilon$是误差，则最小二乘法得到的系数为：
$$
\boldsymbol{a} = \boldsymbol{(X^TX)^{-1}X^Ty}
$$

下面我们使用numpy进行求解。

```python
  import numpy as np # 导入numpy库
  X_origin = np.loadtxt("numpy/data.csv", delimiter=',', encoding="utf-8-sig") # 导入原始数据
  
  ## 通过矩阵过滤、分片，提取出各个性别的X与y
  X0 = X_origin[X_origin[:, 0] == 0, 2]
  y0 = X_origin[X_origin[:, 0] == 0, 3]
  X1 = X_origin[X_origin[:, 0] == 1, 1]
  y1 = X_origin[X_origin[:, 0] == 1, 3]
  
  ## 在X中添加常数项
  X0 = np.c_[np.ones((X0.shape[0], 1)), X0]
  X1 = np.c_[np.ones((X1.shape[0], 1)), X1]
  
  ## 利用公式计算a
  a0 = np.linalg.inv(X0.T @ X0) @ X0.T @ y0
  a1 = np.linalg.inv(X1.T @ X1) @ X1.T @ y1
  
  ## 打印结果
  print(a0)
  print(a1)
```

## 参考资料
  - 《数据科学》课程课件. 丛培盛
  - 张量积. 维基百科. [https://zh.wikipedia.org/wiki/张量积](https://zh.wikipedia.org/wiki/张量积)
  - Numpy API参考文档. [https://numpy.org/doc/stable/reference/index.html](https://numpy.org/doc/stable/reference/index.html)
  - Stackoverflow. [https://stackoverflow.com/questions/10894323/what-does-the-c-underscore-expression-c-do-exactly](https://stackoverflow.com/questions/10894323/what-does-the-c-underscore-expression-c-do-exactly)